time2
rm(list=ls())#
library(FREE)#
data <- FREEdataSim()#
data.list <- list(y=data$y.iid, VAR1=data$x$VAR1, VAR2=data$x$VAR2)#
time1 <- system.time(FREEfit(y ~ VAR1 + VAR2, data=data.list, bins=data$bins, method="gamboost"))[["elapsed"]]#
time2 <- system.time(FREEfit(y ~ VAR1 + VAR2, data=data.list, bins=data$bins, method="gamboost",#
                 bootstrap.cis=TRUE, n.bs=50))[["elapsed"]]
library(INLA)
?inla
?control.family
names(inla.models()$likelihood)
inla.models()$likelihood$binomial
inla.models()$likelihood$binomial$link
a <- matrix(rnorm(64), nrow=8)
a
write.table(a, file="test_data.txt", row.names=FALSE)
getwd()
write.table(a, file="test_data.txt", row.names=FALSE, col.names=FALSE)
a <- matrix(rnorm(64), nrow=8)
write.table(a, file="data.txt", col.names=FALSE, row.names=FALSE, sep="\t")
write.table(a, file="data.txt", col.names=FALSE, row.names=FALSE, sep=" ")
write.table(a, file="data2.txt", col.names=FALSE, row.names=FALSE, sep="\t")
a <- matrix(rnorm(64), nrow=8)
write.csv(a, file="data.csv")
write.csv(a, file="data.csv", row.names=FALSE, col.names=FALSE)
write.csv(a, file="data.csv", row.names=FALSE)
seq(-1.832123, 2.616489, by=0.444861)
?seq
DO.meas <- rnorm(100)#
delta <- vector(0, length=(length(DO.meas) - 1))#
for (i in seq(along=DO.meas)) {#
  delta[i] <- DO.meas[i + 1] - DO.meas[i]#
}
DO.meas <- rnorm(100)#
delta <- vector("numeric", length=(length(DO.meas) - 1))#
for (i in seq(along=DO.meas)) {#
  delta[i] <- DO.meas[i + 1] - DO.meas[i]#
}
delta
seq(along=c(1,2,3))
seq(along=c(1,2,5))
DO.meas <- rnorm(100)#
delta <- vector("numeric", length=(length(DO.meas) - 1))#
for (i in seq(along=delta)) {#
  delta[i] <- DO.meas[i + 1] - DO.meas[i]#
}
delta
length(delta)
vector("numeric")
vector("numeric", 1)
vector("numeric", 2)
n <- 100#
#
DO.meas <- rnorm(n)#
#
delta <- vector("numeric", length=(length(DO.meas) - 1))#
for (i in seq(along=delta)) {#
  delta[i] <- DO.meas[i + 1] - DO.meas[i]#
}#
#
pow_light_p <- rnorm(n)#
power_theta_temp <- rnorm(n)#
Da <- rnorm(n)#
Dz <- rnorm(n)#
Dv <- rnorm(n)#
#
delta_mod <- delta + Da[2:length(Da)] - Dz[2:length(Dz)] + Dv[2:length(Dv)]#
delta.lm <- lm(delta_mod ~ pow_light_p + power_theta_temp)
n <- 100#
#
DO.meas <- rnorm(n)#
#
delta <- vector("numeric", length=(length(DO.meas) - 1))#
for (i in seq(along=delta)) {#
  delta[i] <- DO.meas[i + 1] - DO.meas[i]#
}#
#
pow_light_p <- rnorm(n)#
power_theta_temp <- rnorm(n)#
Da <- rnorm(n)#
Dz <- rnorm(n)#
Dv <- rnorm(n)#
#
delta_mod <- delta + Da[2:n] - Dz[2:n] + Dv[2:n]#
delta.lm <- lm(delta_mod ~ pow_light_p[2:n] + power_theta_temp[2:n])
delta.lm
summary(delta.lm)
coef(delta.lm)
names(delta.lm)
delta.lm$coefficients
library(INLA)
delta.inla <- inla(delta_mod ~ pow_light_p[2:n] + power_theta_temp[2:n])
data.list <- list(y=delta_mod, light_p=pow_light_p[2:n], theta_temp=power_theta_temp[2:n])#
delta.inla <- inla(y ~ light_p + theta_temp, data=data.list)
delta.inla
summary(delta.inla)
coef(delta.inla)
names(delta.inla)
delta.inla$summary.fixed
delta.inla <- inla(y ~ -1 + light_p + theta_temp, data=data.list)
delta.inla$summary.fixed
delta.inla$summary.fixed$theta_temp
delta.inla$summary.fixed$theta_temp[2, ]
delta.inla$summary.fixed[2, ]
delta.lm
coef(delta.lm)
delta.lm <- lm(delta_mod ~ -1 + pow_light_p[2:n] + power_theta_temp[2:n])
coef(delta.lm)
coef(delta.lm)[1]
coef(delta.lm)[2]
library(INLA)#
#
n <- 100#
#
DO.meas <- rnorm(n)#
#
delta <- vector("numeric", length=(length(DO.meas) - 1))#
for (i in seq(along=delta)) {#
  delta[i] <- DO.meas[i + 1] - DO.meas[i]#
}#
#
pow_light_p <- rnorm(n)#
power_theta_temp <- rnorm(n)#
Da <- rnorm(n)#
Dz <- rnorm(n)#
Dv <- rnorm(n)#
#
delta_mod <- delta + Da[2:n] - Dz[2:n] + Dv[2:n]#
#
delta.lm <- lm(delta_mod ~ -1 + pow_light_p[2:n] + power_theta_temp[2:n])#
A.lm <- coef(delta.lm)[1]#
R.lm <- -coef(delta.lm)[2]#
#
data.list <- list(y=delta_mod, light_p=pow_light_p[2:n], theta_temp=power_theta_temp[2:n])#
delta.inla <- inla(y ~ -1 + light_p + theta_temp, data=data.list)#
#
A.inla <- delta.inla$summary.fixed[1, ]#
R.inla <- -delta.inla$summary.fixed[2, ]
A.inla
A.lm
R.lm
R.inla
names(delta.lm)
delta.lm$effects
names(delta.lm)
A.inla
A.inla[1]
library(INLA)#
#
n <- 100#
#
DO.meas <- rnorm(n)#
#
delta <- vector("numeric", length=(length(DO.meas) - 1))#
for (i in seq(along=delta)) {#
  delta[i] <- DO.meas[i + 1] - DO.meas[i]#
}#
#
pow_light_p <- rnorm(n)#
power_theta_temp <- rnorm(n)#
Da <- rnorm(n)#
Dz <- rnorm(n)#
Dv <- rnorm(n)#
#
delta_mod <- delta + Da[2:n] - Dz[2:n] + Dv[2:n]#
#
delta.lm <- lm(delta_mod ~ -1 + pow_light_p[2:n] + power_theta_temp[2:n])#
A.lm <- coef(delta.lm)[1]#
R.lm <- -coef(delta.lm)[2]#
#
data.list <- list(y=delta_mod, light_p=pow_light_p[2:n], theta_temp=power_theta_temp[2:n])#
delta.inla <- inla(y ~ -1 + light_p + theta_temp, data=data.list)#
A.inla <- delta.inla$summary.fixed[1, ]#
R.inla <- -delta.inla$summary.fixed[2, ]#
#
n.sim <- 10000#
DO.mod <- matrix(data=0, nrow=n.sim, ncol=(n - 1))#
mu.mean <- A.inla[1] * pow_light_p - R.inla[1] * power_theta_temp - Da + Dz - Dv#
mu.lower <- A.inla[3] * pow_light_p - R.inla[3] * power_theta_temp - Da + Dz - Dv#
mu.upper <- A.inla[5] * pow_light_p - R.inla[5] * power_theta_temp - Da + Dz - Dv#
mu.sd <- (mu.upper - mu.lower) / 4#
for (i in 2:n) {#
  mu.sim <- rnorm(n.sim, mu.mean, mu.sd)#
  DO.mod[1:n.sim, i] <- DO.mod[1:n.sim, i - 1] + mu.sim[i]#
}
warnings()
n.sim
mu.mean
mu.sd
mu.upper
mu.lower
diff(mu.upper, mu.lower)
mu.upper[1:5]
mu.lower[1:5]
mu.upper[1:5] - mu.lower[1:5]
mu.sd[1:5]
library(INLA)#
#
n <- 100#
#
DO.meas <- rnorm(n)#
#
delta <- vector("numeric", length=(length(DO.meas) - 1))#
for (i in seq(along=delta)) {#
  delta[i] <- DO.meas[i + 1] - DO.meas[i]#
}#
#
pow_light_p <- rnorm(n)#
power_theta_temp <- rnorm(n)#
Da <- rnorm(n)#
Dz <- rnorm(n)#
Dv <- rnorm(n)#
#
delta_mod <- delta + Da[2:n] - Dz[2:n] + Dv[2:n]#
#
delta.lm <- lm(delta_mod ~ -1 + pow_light_p[2:n] + power_theta_temp[2:n])#
A.lm <- coef(delta.lm)[1]#
R.lm <- -coef(delta.lm)[2]#
#
data.list <- list(y=delta_mod, light_p=pow_light_p[2:n], theta_temp=power_theta_temp[2:n])#
delta.inla <- inla(y ~ -1 + light_p + theta_temp, data=data.list)#
A.inla <- delta.inla$summary.fixed[1, ]#
R.inla <- -delta.inla$summary.fixed[2, ]#
#
n.sim <- 10000#
DO.mod <- matrix(data=0, nrow=n.sim, ncol=(n - 1))#
mu.mean <- A.inla[1] * pow_light_p - R.inla[1] * power_theta_temp - Da + Dz - Dv#
mu.lower <- A.inla[3] * pow_light_p - R.inla[3] * power_theta_temp - Da + Dz - Dv#
mu.upper <- A.inla[5] * pow_light_p - R.inla[5] * power_theta_temp - Da + Dz - Dv#
mu.sd <- (mu.upper - mu.lower) / 4#
for (i in 2:n) {#
  mu.sim <- rnorm(n.sim, mu.mean, abs(mu.sd))#
  DO.mod[1:n.sim, i] <- DO.mod[1:n.sim, i - 1] + mu.sim[i]#
}
DO.mod
dim(DO.mod)
library(INLA)#
#
n <- 100#
#
DO.meas <- rnorm(n)#
#
delta <- vector("numeric", length=(length(DO.meas) - 1))#
for (i in seq(along=delta)) {#
  delta[i] <- DO.meas[i + 1] - DO.meas[i]#
}#
#
pow_light_p <- rnorm(n)#
power_theta_temp <- rnorm(n)#
Da <- rnorm(n)#
Dz <- rnorm(n)#
Dv <- rnorm(n)#
#
delta_mod <- delta + Da[2:n] - Dz[2:n] + Dv[2:n]#
#
delta.lm <- lm(delta_mod ~ -1 + pow_light_p[2:n] + power_theta_temp[2:n])#
A.lm <- coef(delta.lm)[1]#
R.lm <- -coef(delta.lm)[2]#
#
data.list <- list(y=delta_mod, light_p=pow_light_p[2:n], theta_temp=power_theta_temp[2:n])#
delta.inla <- inla(y ~ -1 + light_p + theta_temp, data=data.list)#
A.inla <- delta.inla$summary.fixed[1, ]#
R.inla <- -delta.inla$summary.fixed[2, ]#
#
n.sim <- 10000#
DO.mod <- matrix(data=0, nrow=n.sim, ncol=n)#
mu.mean <- A.inla[1] * pow_light_p - R.inla[1] * power_theta_temp - Da + Dz - Dv#
mu.lower <- A.inla[3] * pow_light_p - R.inla[3] * power_theta_temp - Da + Dz - Dv#
mu.upper <- A.inla[5] * pow_light_p - R.inla[5] * power_theta_temp - Da + Dz - Dv#
mu.sd <- (mu.upper - mu.lower) / 4#
for (i in 2:n) {#
  mu.sim <- rnorm(n.sim, mu.mean, abs(mu.sd))#
  DO.mod[1:n.sim, i] <- DO.mod[1:n.sim, i - 1] + mu.sim[i]#
}
plot(DO.mod[1,])
plot(DO.mod[2,])
plot(DO.mod[3,])
library(INLA)#
#
n <- 100#
#
DO.meas <- rnorm(n)#
#
delta <- vector("numeric", length=(length(DO.meas) - 1))#
for (i in seq(along=delta)) {#
  delta[i] <- DO.meas[i + 1] - DO.meas[i]#
}#
#
pow_light_p <- rnorm(n)#
power_theta_temp <- rnorm(n)#
Da <- rnorm(n)#
Dz <- rnorm(n)#
Dv <- rnorm(n)#
#
delta_mod <- delta + Da[2:n] - Dz[2:n] + Dv[2:n]#
#
delta.lm <- lm(delta_mod ~ -1 + pow_light_p[2:n] + power_theta_temp[2:n])#
A.lm <- coef(delta.lm)[1]#
R.lm <- -coef(delta.lm)[2]#
#
data.list <- list(y=delta_mod, light_p=pow_light_p[2:n], theta_temp=power_theta_temp[2:n])#
delta.inla <- inla(y ~ -1 + light_p + theta_temp, data=data.list)#
A.inla <- delta.inla$summary.fixed[1, ]#
R.inla <- -delta.inla$summary.fixed[2, ]#
#
n.sim <- 10000#
DO.mod <- matrix(data=0, nrow=n.sim, ncol=n)#
mu.mean <- A.inla[1] * pow_light_p - R.inla[1] * power_theta_temp - Da + Dz - Dv#
mu.lower <- A.inla[3] * pow_light_p - R.inla[3] * power_theta_temp - Da + Dz - Dv#
mu.upper <- A.inla[5] * pow_light_p - R.inla[5] * power_theta_temp - Da + Dz - Dv#
mu.sd <- (mu.upper - mu.lower) / 4#
for (i in 2:n) {#
  mu.sim <- rnorm(n.sim, mu.mean[i], abs(mu.sd[i]))#
  DO.mod[1:n.sim, i] <- DO.mod[1:n.sim, i - 1] + mu.sim#
}
plot(DO.mod[1,])
plot(DO.mod[2,])
plot(DO.mod[3,])
plot(DO.mod[4,])
plot(DO.mod[5,])
DO.mod.lower <- apply(DO.mod, 2, quantile, p=0.025)
DO.mod.mean <- apply(DO.mod, 2, mean)
DO.mod.upper <- apply(DO.mod, 2, quantile, p=0.975)
plot(DO.mod.mean, type='l')
lines(DO.mod.lower, lty=2)
lines(DO.mod.upper, lty=2)
Load libraries#
library(INLA)#
#
# Set number of measurements#
n <- 100#
#
# Input DO data - can calculate n directly from these data#
DO.meas <- rnorm(n)#
# n <- length(DO.meas)#
#
# Calculate delta values#
delta <- vector("numeric", length=(length(DO.meas) - 1))#
for (i in seq(along=delta)) {#
  delta[i] <- DO.meas[i + 1] - DO.meas[i]#
}#
#
# Input light, temp and diffusion data (simulated here from normal distribution)#
pow_light_p <- rlnorm(n)#
power_theta_temp <- rlnorm(n)#
Da <- rlnorm(n)#
Dz <- rlnorm(n)#
Dv <- rlnorm(n)#
#
# Move the diffusion terms to the LHS (add them to delta)#
delta_mod <- delta + Da[2:n] - Dz[2:n] + Dv[2:n]#
#
# Fit a standard linear model (just for interest)#
delta.lm <- lm(delta_mod ~ -1 + pow_light_p[2:n] + power_theta_temp[2:n])#
# Extract coefficients (mean values only)#
A.lm <- coef(delta.lm)[1]#
R.lm <- -coef(delta.lm)[2]#
#
# Fit an INLA linear model#
data.list <- list(y=delta_mod, light_p=pow_light_p[2:n], theta_temp=power_theta_temp[2:n])#
delta.inla <- inla(y ~ -1 + light_p + theta_temp, data=data.list)#
# Extract coefficients (means, sds, quantiles)#
A.inla <- delta.inla$summary.fixed[1, ]#
R.inla <- -delta.inla$summary.fixed[2, ]#
#
# Set number of simulated DO.mod runs#
n.sim <- 10000#
# Initialise DO.mod matrix (one row for each simulated run)#
DO.mod <- matrix(data=0, nrow=n.sim, ncol=n)#
# Calculate mean and sd of mu at each measurement#
mu.mean <- A.inla[1] * pow_light_p - R.inla[1] * power_theta_temp - Da + Dz - Dv#
mu.lower <- A.inla[3] * pow_light_p - R.inla[3] * power_theta_temp - Da + Dz - Dv#
mu.upper <- A.inla[5] * pow_light_p - R.inla[5] * power_theta_temp - Da + Dz - Dv#
mu.sd <- (mu.upper - mu.lower) / 4#
# Loop through each measurement and simulate a value for DO#
for (i in 2:n) {#
  # Use mean and sd of mu at each measurement to simulate from a normal distribution#
  mu.sim <- rnorm(n.sim, mu.mean[i], mu.sd[i])#
  # Store simulated value into DO.mod matrix#
  DO.mod[1:n.sim, i] <- DO.mod[1:n.sim, i - 1] + mu.sim#
}#
# Calculate mean and 95% intervals based on the n.sim simulations of DO.mod#
DO.mod.mean <- apply(DO.mod, 2, mean)#
DO.mod.lower <- apply(DO.mod, 2, quantile, p=0.025)#
DO.mod.upper <- apply(DO.mod, 2, quantile, p=0.975)
plot(DO.mod.mean, type='l')
lines(DO.mod.lower, lty=2)
lines(DO.mod.upper, lty=2)
min(mu.sd)
library(FREE)
data <- FREEdataSim()
head(data$y.idd)
head(data$y.iid)
data$y
data$y <- round(12*(data$y.iid + 2))
head(data$y)
min(data$y)
data$y <- data$y + 1
min(data$y)
max(data$y)
hist(data$y)
head(data$x)
names(data)
write.table(data$x, file="preds.txt", row.names=FALSE, col.names=FALSE)
head(data$y)
data$bins
data$bins <- seq(1, 15, length=21)
data$bins
rep(data$bins, each=data$y[1,])
rep(data$bins, data$y[1,])
head(data$y)
apply(data$y, 1, sum)
range(apply(data$y, 1, sum))
y.store <- matrix(data=NA, nrow=100, ncol=562)
for(i in 1:nrow(y.store)) {y.store[i, 1:apply(data$y, 1, sum)[i]] <- rep(data$bins, data$y[i,])}
head(y.store)
dim(y.store)
write.table(y.store, file="response.txt", row.names=FALSE, col.names=FALSE)
library(mboost)
cite(mboost)
cite("mboost")
?cite
citation(mboost)
citation("mboost")
library(INLA)
citation("INLA")
library(FREE)
data <- FREEdataSim()
data.list <- list(y=data$y.iid, VAR1=data$x$VAR1, VAR2=data$x$VAR2)
names(data.list)
FREEtime <- system.time(inla.test <- FREEfit(y ~ VAR1 + VAR2, data=data.list, method="INLA"))[["elapsed"]]
FREEtime
summary(inla.test)
plot(inla.test)
yv <- as.vector(data.list$y)
v1 <- rep(data.list$VAR1, length(data$bins))
length(data$bins)
v2 <- rep(data.list$VAR2, length(data.bins))
v2 <- rep(data.list$VAR2, length(data$bins))
bin = rep(data$bins, each=100)
bin0 = bin1 = bin2 = bin
head(bin0)
site <- as.factor(rep(c(1:100), 21))
length(site)
length(bin)
length(bin0)
fmla = yv ~ f(bin0, model="rw2") + f(bin1, v1, model="rw2") + f(bin2, v2, model="rw2") + f(site, model="iid")
inladat = data.frame(yv, v1, v2, bin0, bin1, bin2, site)
INLAtime <- system.time(inla.test2 <- inla(fmla, data=inladat))[["elapsed"]]
INLAtime
FREEtime
plot(INLAtime)
plot(inla.test2)
names(inla.test2)
summary(inla.test2)
names(inla.test2)
cor(inla.test2$summary.fitted, yv)
cor(inla.test2$summary.fitted$mean, yv)
cor(inla.test2$summary.fitted.values, yv)
cor(inla.test2$summary.fitted.values$mean, yv)
inla.test2$summary.fitted.values
names(inla.test2)
INLAtime <- system.time(inla.test2 <- inla(fmla, data=inladat, control.inla=list(compute=T)))[["elapsed"]]
INLAtime <- system.time(inla.test2 <- inla(fmla, data=inladat, control.predictor=list(compute=T)))[["elapsed"]]
INLAtime
cor(inla.test2$summary.fitted.values$mean, yv)
inla.test$r2
FREE:::FREEinla
FREE:::MakeINLAformula
FREE:::MakeInlaFormula
FREE:::FREEfit.default
FREE:::FREEfit.formula
FREE:::MakeInlaFormula
FREEtime <- system.time(inla.test <- FREEfit(y ~ VAR1 + VAR2, data=data.list, method="INLA", errors="iid"))[["elapsed"]]
FREEtime
INLAtime
inla.test$r2
cor(inla.test2$summary.fitted.values$mean, yv)**2
plot(inla.test)
?plot.inla
plot(inla.test2)
coef(inla.test)
FREE:::coef.FREEfit
inla.test$coefs.mean
inla.test$coefs.sd
inla.test
names(inla.test2)
inla.test2$summary.random
FREE:::FREEinla
library(FREE)
FREE:::FREEinla
FREE:::MakeInlaFormula
FREE:::FREEbugsJump
MakeInlaFormula <-#
function(n.vars=2, var.names=NULL, model.int="rw2", model.pred="rw2", model.site="iid", model.eij="ar1", order=NULL, diag.int=1e-5, diag.pred=0.1, prec.prior=c(0.1,1e-3), group.mean=FALSE, n.groups=10, group.vars=FALSE, n.groups.var=10){#
  if (is.null(var.names)) {#
    var.names <- NULL#
    for (i in 1:n.vars) {#
      var.names <- c(var.names, paste("VAR", i, sep=""))#
    }#
  }#
  if (group.mean) {#
    int.temp <- paste("y ~ -1 + f(inla.group(bin.int, n=", n.groups, "), model='",#
                       model.int, "', diagonal=", diag.int, ", constr=F)", sep="")#
  } else {#
    int.temp <- paste("y ~ -1 + f(bin.int, model='", model.int, "', diagonal=", diag.int, ",#
                       constr=F)", sep="")#
  }#
  var.temp <- NULL#
  var.lin.temp <- NULL#
  for (i in 1:n.vars) {#
    if (group.vars) {#
      bin.int.temp <- paste("inla.group(bin.int", i, ", n=", n.groups.var, ")", sep="")#
    } else {#
      bin.int.temp <- paste("bin.int", i, sep="")#
    }#
    var.temp <- paste(var.temp, " + f(", bin.int.temp, ",", var.names[i],#
                      ", model='", model.pred, "', hyper=list(prec=list(param=c(",#
                      paste(prec.prior[1], prec.prior[2], sep=','),#
                      "))), diagonal=", diag.pred, ", constr=T)", sep="")#
    var.lin.temp <- paste(var.lin.temp, " + ", var.names[i], sep="")#
  }#
  if (model.eij == "arp") {#
    if(is.null(order)){ stop("User must set order of ARp model...", call.=F)}#
    append.temp <- paste(" + f(SITE, model='", model.site, "')", " + f(bin.int",#
                         (n.vars + 1), ", model='ar', order=", order,#
                         ", replicate=SITE)", sep="")#
  } else {#
  	if (model.eij == "ar1") {#
      append.temp <- paste(" + f(SITE, model='", model.site, "')", " + f(bin.int",#
                           (n.vars + 1), ", model='", model.eij, "', replicate=SITE)",#
                           sep="")#
    } else {#
      append.temp <- paste(" + f(SITE, model='", model.site, "')", sep="")#
    }#
  }#
  formula <- as.formula(paste(int.temp, var.lin.temp, var.temp, append.temp, sep=""))#
  return(formula)#
}
FREEinla <-#
function(y, x, bins, family="gaussian", errors="ar1", model.int="spline",  model.pred="spline", model.site="iid", verbose=FALSE, diag.int=1e-5, diag.pred=0.01, prec.prior=c(1e-1,1e-3), control.predictor.set=list(compute=T), control.compute.set=list(cpo=T, dic=TRUE), ...){#
  data <- ConvertB2A(y, x, bins)#
  y.data <- data$y.vector#
  X.data <- data$X.vector#
  bin.data <- data$bin.vector#
  site.data <- data$sites.vector#
  n.vars <- ncol(X.data)#
  var.names <- colnames(X.data)#
  if (model.int == "spline") {#
    model.int <- "rw2"#
  } else {#
    model.int <- model.int#
  }#
  if (model.pred == "spline") {#
    model.pred <- "rw2"#
  } else {#
    model.pred <- model.pred#
  }#
  formula <- MakeInlaFormula(n.vars=n.vars, var.names=var.names, model.int=model.int,#
                             model.pred=model.pred, diag.int=diag.int, diag.pred=diag.pred,#
                             model.site=model.site, prec.prior=prec.prior, #
                             model.eij=errors,#
                             order=order)#
  inla.data.file <- list(y=y.data, bin.int=bin.data, SITE=site.data)#
  for (i in 1:n.vars) {#
    var.temp <- list(X.data[, var.names[i]])#
    temp.data <- list(bin.data)#
    inla.data.file[length(inla.data.file) + 1] <- temp.data#
    names(inla.data.file)[[length(inla.data.file)]] <- paste("bin.int", i, sep="")#
    inla.data.file[length(inla.data.file) + 1] <- var.temp#
    names(inla.data.file)[[length(inla.data.file)]] <- var.names[i]#
  }#
  inla.data.file[length(inla.data.file) + 1] <- list(bin.data)#
  names(inla.data.file)[[length(inla.data.file)]] <- paste("bin.int", (n.vars + 1), sep="")#
  mod.inla <- inla(formula, family=family, data=inla.data.file,#
                    control.predictor=control.predictor.set,#
                    control.compute=control.compute.set, verbose=verbose, ...)#
  fitted <- matrix(mod.inla$summary.fitted$mean, nrow=nrow(y), byrow=TRUE)#
  fitted.coefs <- names(mod.inla$summary.random[1:{ncol(x) + 1}])#
  coef.vals <- NULL#
  coef.vals.sd <- NULL#
  for (name.use in fitted.coefs) {#
    coef.vals <- cbind(coef.vals, mod.inla$summary.random[[name.use]]$mean)#
    coef.vals.sd <- cbind(coef.vals.sd, mod.inla$summary.random[[name.use]]$sd)#
    if (family == "poisson") {#
      coef.vals <- exp(coef.vals)#
      coef.vals.sd <- exp(coef.vals.sd)#
    }#
  }#
  colnames(coef.vals) <- c("INTERCEPT", var.names)#
  colnames(coef.vals.sd) <- colnames(coef.vals)#
  r <- cor(c(fitted), c(y))#
  r2 <- r * r#
  xIC <- mod.inla$dic$dic#
  return(list(fitted=fitted, observed=y, coefs.mean=t(coef.vals), coefs.sd=t(coef.vals.sd),#
              r2=r2, family=family, bins=bins, xIC=xIC, model=mod.inla, formula2=formula))#
}
setwd("~/Dropbox/fdaMethods/FREE/R")
list.files()
source("ConvertB2A.R")
source("FREEdataSim.R")
source("FREEfit")
source("FREEfit.R")
source("FREEfit.default.R")
source("FREEfit.formula.R")
data <- FREEdataSim()
library(MASS)
data <- FREEdataSim()
source("MakeCovMat.R")
data <- FREEdataSim()
data.list <- list(y=data$y.iid, VAR1=data$x$VAR1, VAR2=data$x$VAR2)
mod.inla <- FREEfit(y ~ VAR1 + VAR2, data=data.list, errors="iid", method="INLA")
library(inla)
library(INLA)
mod.inla <- FREEfit(y ~ VAR1 + VAR2, data=data.list, errors="iid", method="INLA")
mod.inla
mod.inla$coefs.sd
plot(mod.inla$model)
names(mod.inla$model)
mod.inla$model$summary.fixed
plot(data$x$beta.mean[1,])
names(data$x)
names(data)
plot(data$beta.real[1, ], type='l')
lines(mod.inla$coefs.mean[2, ], col='red')
lines(mod.inla$coefs.mean[2, ]-0.11, col='red')
plot(data$beta.real[1, ], type='l')
lines(mod.inla$coefs.mean[2, ]-0.11, col='red')
mod.inla$coefs.sd
mod.inla$model$summary.random
mod.inla$model$summary.random$bin.int1
mod.inla$coefs.sd
mod.inla$model$summary.random$bin.int1[,6] - mod.inla$model$summary.random$bin.int1[,4]
mod.inla$coefs.sd*2
mod.inla$model$summary.random$bin.int1[,6] - mod.inla$model$summary.random$bin.int1[,5]
